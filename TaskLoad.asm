;.MACRO TaskLoader
; Загрузчик задач.Запускается сразу после таймерной службы.
; Проверяет состояние таймеров и флаги прерывания задач.
; Если необходимно запускает задачу, или "будит" её восстанавливая контекст задачи
; При повторном запуске начинает работу не с первой задачи а с "предыдущая+1" 
; чтобы все задачи получили свое процессорное время
; 
; Какие регистры за что отвечают
; taskNumber             = R16 номер задачи которую проверяем в данный момент
; taskState              = R17 регистр состояния задачи

; taskFrameAddr_L        = XL  адрес указатель на структуру с данными задачи
; taskFrameAddr_H        = XH
; taskFrameAddr          = X

; taskFrame_taskStart_L  = ZL указатель на адрес старта задачи, или откуда ее нужно продолжить
; taskFrame_taskStart_H  = ZH
; taskFrame_taskStart    = Z

; tmp                    = R18 временный регистр
; tmp1                   = R19 временный регистр






TaskLoader:             
    NOP
	NOP
	NOP
	; проверям флаг contextType.
	; если включен значит до этого загрузчик задач был прерван по таймеру
	; восстанавливаем контекст загрузчика
	LDS R16, contextType
	
	CPI R16, kernelInitMode ; если contextType == kernelInitMode == 2 
	BREQ TaskLoaderInit
	
	CPI R16, taskMode
	BREQ TaskLoaderInit ; Если contextType == taskMode == 0 то прерывание произошло из задачи. 
						; Ищем следующую подходящую задачу для запуска и запускаем ее
						; Ну а еесли contextType == kernelMode == 1 то прерывание произошло в момент когда работал загрузчик задач 
						; и надо вернуться туда откуда его выдернули
	
	
TaskLoaderRestoreContext:
	CLI
	LDI R16, low(kernel_State-1+2) ; -1 из-за особенностей стековой адресации. +2 чтобы перепрыгнуть неиспользуемый адрес возврата
	OUT SPL, R16	
	LDI R16, high(kernel_State-1+2)
	OUT SPH, R16
	POP R16
	OUT SREG, R16
	POP ZH
	POP ZL
	POP XH
	POP XL
	POP R19
	POP R18
	POP R17
	POP R16
	POP R1
	POP R0	
	NOP
	NOP
	NOP
	RETI

TaskLoaderInit: ;Если  попали сюда по прерыванию из работающей задачи или просто первый раз
	CLI
	LDI R16, kernelMode				 ; включаем флажок что мы работаем в ядре ( нужно для правильного сохранения контекста)
	STS contextType, R16
    LDI R16, low(kernel_State+kernelStackLength-1)  ; При первом запуске устанваливаем корень стека в конец 
    OUT SPL, R16
	LDI R16, high(kernel_State+kernelStackLength-1) ; в конец структуры данных задачи
    OUT SPH, R16            
	; При первом запуске корень стека устанавливается по адресу по умолчанию
	; из-за этого все что было в стеке идёт по пизде
	; При первом запуске это хорошо, не нужно хранить адрес возврата в dummy loop
	; Если мы попали сюда из задачи, то по идее тоже всё пучком контекскт состояния загрузчика задач хранить не надо
	; Подумать что делать если попали сюда из обработчика прерываний 

	SEI   
    
	CLR R16
	RJMP TaskLoader_Next;


	ReinitTaskNumber:
    LDI R16, MAXPROCNUM  


TaskLoader_Next:                   ; Итерация цикла обработки задач
    DEC  R16                       ; R16=7 (8-1)
    BRBS 2, ReinitTaskNumber
    STS  currentTaskNumber, R16    ; перед запуском сохраним номер задачи в память 
    
    MOV  R18, R16                  ; Вычислим адрес структуры с данными для текущей задачи
    LDI  R19, FRAMESIZE
    MUL  R18, R19
    LDI  XL, low(TaskFrame)
    LDI  XH, high(TaskFrame)
    ADD  XL, R0
    ADC  XH, R1
    
    LD   R17, X               ; Загрузили регистр состояния задачи в R17
                              ; проверяем флаги состояния
    SBRC R17, taskWaitInt     ; если задача ждёт прерывания то и пускай ждёт, вызывать мы её не будем 
    RJMP TaskLoader_Next
    
    SBRC R17, taskTimerIsZero ; если таймер не 0 проверяем таймер следующей задачи.
    RJMP TaskLoader_Load      ; таймер == 0, запускаем программу. Сначала или с места остановки
    
    RJMP TaskLoader_Next      ; таймер > 0, идём проверять следующую задачу

TaskLoader_Load:              
    SBRC R17, taskRun         ; проверяем выполняется ли задача, по флагу taskRun
    RJMP TaskLoader_WakeUp    ; если флаг выполения taskRun взведён, 
                              ; то программа уже выполняется и была прервана
                              ; будим программу
        
    SBR  R17, 1<<taskRun         ; Задача не выполняется, ставим флаг taskRun и сохраняем регистр состояния задачи.
    ST   X, R17
        
    CLI						  ; запрещаем прерывания здесь,чтобы не сломать сохранение стека в случае получения прерывания таймера
							  ; а то неудобно получится, если надо будет сохранить контекст ядра, я голова стека показывает на стек задачи
	LDI R18, taskMode		  ; переключились в режим задачи. теперь если сработает прерывание таймера, то сохранится контекст задачи а не ядра
	STS contextType, R18

	SUBI XL, low(-1*FRAMESIZE + 1) ; x-(-80+1) => x+79 ; При первом запуске устанваливаем корень стека в конец 
    SBCI XH, high(-1*FRAMESIZE + 1) ; в конец структуры данных задачи
    OUT  SPL, XL
    OUT  SPH, XH               
        
    ; Запуск задачи
    LDI  ZL, low(taskStartAddress*2) ; загружаем адрес где хранятся адреса стартов задач
    LDI  ZH, high(taskStartAddress*2)
    
    MOV R18, R16        ; прибавляем к адресу смещение равное номеру задачи
    LSL R18             ; умножаю номер задачи на два, ведь читать будем из области кода, а там адресация в словах
    ADD ZL, R18         ; чтобы получить в байтах нужно умножить на 2
    CLR R18
	ADC ZH, R18         ; адрес вычислен и находится в Z

    LPM R18, Z+ ; Загружаем младший бит адреса  старта задачи
    LPM R19, Z  ; И старший бит
    PUSH R18    ; Пушим этот адрес в стек и делаем возврат ( после этого окажемся в контексте выполнения задачи)
    PUSH R19              
    		NOP
		NOP
		NOP
	RETI        ; В конце каждой задачи должно стоять EXIT это макрос который перебрасывает на следующую задачу

TaskLoader_WakeUp:			  ; Будим задачу
   CLI						  ; запрещаем прерывания здесь,чтобы не сломать сохранение стека в случае получения прерывания таймера
							  ; а то неудобно получится, если надо будет сохранить контекст ядра, я голова стека показывает на стек задачи

   LDI R18, 0				  ; переключились в режим задачи. теперь если сработает прерывание таймера, то сохранится контекст задачи а не ядра
   STS contextType, R18
   
   SUBI XL,  low(-1*TaskStackRootShift) ; установить голову стека задачи ( это конец стекового кадра )
   SBCI XH, high(-1*TaskStackRootShift) ; загрузили адрес по которому лежит адрес головы стека запущенного таска
   
   LD R16, Z+ ; Младший байт с адресом головы стека
   LD R17, Z ; Старший байт

   OUT  SPL, R16
   OUT  SPH, R17    ; Устанавливаем голову стека
   
   LoadContextMacro ; Восстанавливаем контекст и возвращаемся к задаче 

TaskLoader_TaskExit: ;Сюда попадаем после выполнения макроса EXIT
   CLI					
   LDI R18, kernelMode				  ; Послевыхода из задачи переключились  обратно в режим ядра 
   STS contextType, R18
   SEI

   ; Что делается когда задача завершилась?
   ; Снимаем флаг выполнения      
   LDS  R16, currentTaskNumber ; загрузили номер текущей задачи, после выполнения задачи
   MOV  R18, R16               ; считаем смещение чтобы утановить стековый кадр
   LDI  R19, FRAMESIZE
   MUL  R18, R19
   LDI  XL, low(TaskFrame) 
   LDI  XH, high(TaskFrame)
   ADD  XL, R0
   ADC  XH, R1
   LD   R17, X                 ; Регистр состояния теперь лежит в R17
   CBR  R17, 1<<taskRun           ; Clear Bit register " taskRun"
   CBR  R17, 1<<taskTimerIsZero
   ST   X+, R17                ; Сохранили регистр состояния задачи и сместили указатель на таймер задачи
   
   ; Тут надо загрузить дефолтное значение таймера из памяти программ
   LDI  ZL,  low(DefaultTimer*2)
   LDI  ZH, high(DefaultTimer*2)
   
   MOV  R18, R16 ; вычисляю смещение до адреса с дефолтным таймером текущей задачи
   LSL  R18               
   
   ADD ZL, R18   ; смещаюсь на адрес с дефолтным таймером текущей задачи
   CLR R18
   ADC ZH, R18
   
   LPM  R18, Z ; Загрузили дефолтное значение таймера 
   
   ST   X+, R18 ; младший байт, пишем дефолтное значение
   CLR  R18         
   ST   X+, R18 ; очищаем три старших байта таймера и записываем дефолтное значение в младший
   ST   X+, R18
   ST   X,  R18 
   
TaskBreak:                         ; если задача передала управление ядру по любой причине кроме exit то мы попадаем сюда ведь задача должна просто немного подождать
   RJMP TaskLoader_Next