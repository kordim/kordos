.MACRO TaskLoader
; Загрузчик задач.Запускается сразу после таймерной службы.
; Проверяет состояние таймеров и флаги прерывания задач.
; Если необходимно запускает задачу, или "будит" её восстанавливая контекст задачи
; При повторном запуске начинает работу не с первой задачи а с "предыдущая+1" 
; чтобы все задачи получили свое процессорное время
; 
; Какие регистры за что отвечают
; taskNumber             = R16 номер задачи которую проверяем в данный момент
; taskState              = R17 регистр состояния задачи

; taskFrameAddr_L        = XL  адрес указатель на структуру с данными задачи
; taskFrameAddr_H        = XH
; taskFrameAddr          = X

; taskFrame_taskStart_L  = ZL указатель на адрес старта задачи, или откуда ее нужно продолжить
; taskFrame_taskStart_H  = ZH
; taskFrame_taskStart    = Z

; tmp                    = R18 временный регистр
; tmp1                   = R19 временный регистр

TaskLoader_Init:             ; При первом запуске начинаем с самого начала 
    CLI
    LDI R16, MAXPROCNUM
    STS currentTaskNumber, R16

TaskLoader_Next:                   ; Итерация цикла обработки задач
    DEC  R16                       ; R16=7 (8-1)
    BRCS TaskLoader_Init
    STS  currentTaskNumber, R16    ; перед запуском сохраним номер задачи в память 
    
    MOV  R18, R16                  ; Вычислим адрес структуры с данными для текущей задачи
    LDI  R19, FRAMESIZE
    MUL  R18, R19
    LDI  XL, low(TaskFrame)
    LDI  XH, high(TaskFrame)
    ADD  XL, R0
    ADC  XH, R1
    
    LD   R17, X               ; Загрузили регистр состояния задачи в R17
                              ; проверяем флаги состояния
    SBRC R17, taskWaitInt     ; если задача ждёт прерывания то и пускай ждёт, вызывать мы её не будем 
    RJMP TaskLoader_Next
    
    SBRC R17, taskTimerIsZero ; если таймер не 0 проверяем таймер следующей задачи.
    RJMP TaskLoader_Load      ; таймер == 0, запускаем программу. Сначала или с места остановки
    
    RJMP TaskLoader_Next      ; таймер > 0, идём проверять следующую задачу

TaskLoader_Load:              
    SBRC R17, taskRun         ; проверяем выполняется ли задача, по флагу taskRun
    RJMP TaskLoader_WakeUp    ; если флаг выполения taskRun взведён, 
                              ; то программа уже выполняется и была прервана
                              ; будим программу
        
    SBR  R17, taskRun         ; Задача не выполняется, ставим флаг taskRun и сохраняем регистр состояния задачи.
    ST   X, R17
        
    SUBI XL, low(-1*FRAMESIZE)  ; При первом запуске устанваливаем корень стека в конец 
    SBCI XH, high(-1*FRAMESIZE) ; в конец структуры данных задачи
    OUT  SPL, XL
    OUT  SPH, XH               
        
    ; Запуск задачи
    LDI  ZL, low(taskStartAddress*2) ; загружаем адрес где хранятся адреса стартов задач
    LDI  ZH, high(taskStartAddress*2)
    
    MOV  R18, R16        ; прибавляем к адресу смещение равное номеру задачи
    LSL  R18             ; умножаю номер задачи на два, ведь читать будем из области кода, а там адресация в словах
    ADD  ZL, R18         ; чтобы получить в байтах нужно умножить на 2
    SBRC SREG, 0 
    INC ZH               ; адрес вычислен и находится в Z

    LPM R18, Z+ ; Загружаем младший бит адреса  старта задачи
    LPM R19, Z  ; И старший бит
    PUSH R18    ; Пушим этот адрес в стек и делаем возврат ( после этого окажемся в контексте выполнения задачи)
    PUSH R19              
    RETI        ; В конце каждой задачи должно стоять EXIT это макрос который перебрасывает на следующую задачу

TaskLoader_WakeUp: ; Будим задачу
   SUBI XL,  low(-1*TaskStackRootShift) ; установить голову стека задачи ( это конец стекового кадра )
   SBCI XH, high(-1*TaskStackRootShift) ; загрузили адрес по которому лежит адрес головы стека запущенного таска
   
   LD Z+, R17 ; Младший байт с адресом головы стека
   LD Z,  R16 ; Старший байт

   OUT  SPH, R17    ; Устанавливаем голову стека
   OUT  SPL, R16
   LoadContextMacro ; Восстанавливаем контекст и возвращаемся к задаче 

TaskLoader_TaskExit: ;Сюда попадаем после выполнения макроса EXIT
   ; Что делается когда задача завершилась?
   ; Снимаем флаг выполнения
   LDS  R16, currentTaskNumber ; загрузили номер текущей задачи, после выполнения задачи
   MOV  R18, R16               ; считаем смещение чтобы утановить стековый кадр
   LDI  R19, FRAMESIZE
   MUL  R18, R19
   LDI  XL, low(TaskFrame) 
   LDI  XH, high(TaskFrame)
   ADD  XL, R0
   ADC  XH, R1
   LD   R17, X                 ; Регистр состояния теперь лежит в R17
   CBR  R17, taskRun           ; Clear Bit register " taskRun"
   ST   X+, R17                ; Сохранили регистр состояния задачи и сместили указатель на таймер задачи
   
   ; Тут надо загрузить дефолтное значение приоритета из таблицы в памяти программ
   LDI  ZL,  low(DefaultTimer*2)
   LDI  ZH, high(DefaultTimer*2)
   
   MOV  R18, R16 ; вычисляю смещение до адреса с дефолтным таймером текущей задачи
   LSL  R18               
   
   ADD  ZL, R18   ; смещаюсь на адрес с дефолтным таймером текущей задачи
   SBRC SREG, 0   
   INC  ZH
   
   LPM  R18, Z ; Загрузили дефолтное значение таймера 
   
   ST   X+, R18 ; младший байт, пишем дефолтное значение
   CLR  R18         
   ST   X+, R18 ; очищаем три старших байта таймера и записываем дефолтное значение в младший
   ST   X+, R18
   ST   X,  R18 
   
TaskBreak:                         ; если задача передала управление ядру по любой причине кроме exit то мы попадаем сюда ведь задача должна просто немного подождать
   RJMP TaskLoader_Next

.ENDM

